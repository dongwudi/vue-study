## 构建脚本
package.json中这3条命令都是用来构建vue.js的，实际运行的是`scripts/build.js`
```
    "build": "node scripts/build.js",
    "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",
    "build:weex": "npm run build -- weex",
```
## 构建过程
先把所有关联的映射配置代码找到：
1. 在`scripts/build.js`中（从配置文件读取配置，再通过命令行参数对构建配置做过滤）
```
let builds = require('./config').getAllBuilds()
```
2. 在`scripts/config.js`中（Vue.js 构建的配置）  
单个配置遵循Rollup的构建规则  
entry 属性表示构建的入口 JS 文件地址  
dest 属性表示构建后的 JS 文件地址  
format 属性表示构建的格式    
cjs 表示构建出来的文件遵循 CommonJS 规范  
es 表示构建出来的文件遵循 ES Module 规范  
umd 表示构建出来的文件遵循 UMD 规范  
```
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}

const builds = {
  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.dev.js'),
    format: 'cjs',
    env: 'development',
    banner
  },
  ...
  ...
}
...

if (process.env.TARGET) {
  module.exports = genConfig(process.env.TARGET)
} else {
  exports.getBuild = genConfig
  exports.getAllBuilds = () => Object.keys(builds).map(genConfig)
}
```
3. 在`scripts/alias.js`中（对应实际的vue.js源文件，经过rollup打包会在dist目录下生成对应的文件）
```
const path = require('path')

const resolve = p => path.resolve(__dirname, '../', p)

module.exports = {
  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),
  compiler: resolve('src/compiler'),
  core: resolve('src/core'),
  shared: resolve('src/shared'),
  web: resolve('src/platforms/web'),
  weex: resolve('src/platforms/weex'),
  server: resolve('src/server'),
  sfc: resolve('src/sfc')
}
```
